import cv2
import numpy as np
import matplotlib.pyplot as plt

image_path = 'Alex ID.jpg'
image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)

image = cv2.resize(image, (300, 300))

if image is not None:
  image_array = np.array(image)

  print(f"Image shape: {image_array.shape}")

  plt.imshow(image, cmap='gray')
  plt.axis('off')
  plt.show()
else:
  print(f"Error: Unable to load image from {image_path}")



import cv2
import numpy as np
import matplotlib.pyplot as plt

image_path = 'Alex ID.jpg'
image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)

image = cv2.resize(image, (300, 300))

if image is not None:
  image_array = np.array(image)

  print(f"Image shape: {image_array.shape}")

  plt.imshow(image, cmap='gray')
  plt.axis('off')
  plt.show()
else:
  print(f"Error: Unable to load image from {image_path}")





kernel = np.ones((9, 9), dtype=np.float32) / 81.0

image_array = cv2.imread('Alex ID.jpg', cv2.IMREAD_GRAYSCALE)
image_array = cv2.resize(image_array, (300, 300))
image_array = image_array.astype(np.float32)

image_height, image_width = image_array.shape
kernel_height, kernel_width = kernel.shape

pad_height = kernel_height // 2
pad_width = kernel_width // 2

output_image = np.zeros_like(image_array).astype(np.float32)

for i in range(image_height):
    for j in range(image_width):
        for m in range(kernel_height):
            for n in range(kernel_width):
                image_row = i - pad_height + m
                image_col = j - pad_width + n

                if 0 <= image_row < image_height and 0 <= image_col < image_width:
                    output_image[i, j] += image_array[image_row, image_col] * kernel[m, n]


from scipy.signal import convolve2d
output_image2 = convolve2d(image_array, kernel, mode='same')


plt.figure(figsize=(10, 5))
plt.subplot(1, 2, 1)
plt.imshow(image_array, cmap='gray')
plt.title('Original Image')
plt.axis('off')

plt.subplot(1, 2, 2)
plt.imshow(output_image, cmap='gray')
plt.title('Convolved Image (Box)')
plt.axis('off')

plt.show()

plt.imshow(output_image2, cmap='gray')
plt.title('Convolved Image (Scipy)')
plt.axis('off')
plt.show()



import cv2
import numpy as np
import matplotlib.pyplot as plt

if image_array.ndim == 3:
    gray = cv2.cvtColor(image_array, cv2.COLOR_BGR2GRAY)
else:
    gray = image_array
gray = gray.astype(np.float32)

kernel_dx = np.array([[-1, 0, 1]], dtype=np.float32)
kernel_dy = np.array([[-1], [0], [1]], dtype=np.float32)

D_x = cv2.filter2D(gray, ddepth=cv2.CV_32F, kernel=kernel_dx, borderType=cv2.BORDER_REPLICATE)
D_y = cv2.filter2D(gray, ddepth=cv2.CV_32F, kernel=kernel_dy, borderType=cv2.BORDER_REPLICATE)

magnitude = np.sqrt(D_x**2 + D_y**2)

threshold = 35.0
binary_image = (magnitude > threshold).astype(np.uint8) * 255

D_x_vis = cv2.convertScaleAbs(D_x)
D_y_vis = cv2.convertScaleAbs(D_y)

plt.figure(figsize=(18, 6))
plt.subplot(1, 4, 1); plt.imshow(gray, cmap='gray'); plt.title('Original (gray)'); plt.axis('off')
plt.subplot(1, 4, 2); plt.imshow(D_x_vis, cmap='gray'); plt.title('D_x (horizontal)'); plt.axis('off')
plt.subplot(1, 4, 3); plt.imshow(D_y_vis, cmap='gray'); plt.title('D_y (vertical)'); plt.axis('off')
plt.subplot(1, 4, 4); plt.imshow(binary_image, cmap='gray'); plt.title('|∇I| > threshold'); plt.axis('off')
plt.show()



import cv2
import numpy as np
import matplotlib.pyplot as plt
import math

image_array = cv2.imread('cameraman.png')
if image_array.ndim == 3:
    gray = cv2.cvtColor(image_array, cv2.COLOR_BGR2GRAY)
else:
    gray = image_array
gray = gray.astype(np.float32)

def gaussian_kernel(size, sigma):
    kernel = np.zeros((size, size), dtype=np.float32)
    center = size // 2
    sum_val = 0
    for i in range(size):
        for j in range(size):
            x, y = i - center, j - center
            kernel[i, j] = (1 / (2 * math.pi * sigma**2)) * math.exp(-(x**2 + y**2) / (2 * sigma**2))
            sum_val += kernel[i, j]
    return kernel / sum_val

kernel_size = 5
sigma = 1.0
gaussian_kern = gaussian_kernel(kernel_size, sigma)

gray_blurred = cv2.filter2D(gray, ddepth=cv2.CV_32F, kernel=gaussian_kern, borderType=cv2.BORDER_REPLICATE)

kernel_dx = np.array([[-1, 0, 1]], dtype=np.float32)
kernel_dy = np.array([[-1], [0], [1]], dtype=np.float32)

D_x = cv2.filter2D(gray_blurred, ddepth=cv2.CV_32F, kernel=kernel_dx, borderType=cv2.BORDER_REPLICATE)
D_y = cv2.filter2D(gray_blurred, ddepth=cv2.CV_32F, kernel=kernel_dy, borderType=cv2.BORDER_REPLICATE)

magnitude = np.sqrt(D_x**2 + D_y**2)

threshold = 40.0
binary_image = (magnitude > threshold).astype(np.uint8) * 255

D_x_vis = cv2.convertScaleAbs(D_x)
D_y_vis = cv2.convertScaleAbs(D_y)

plt.figure(figsize=(18, 6))
plt.subplot(1, 4, 1); plt.imshow(gray_blurred, cmap='gray'); plt.title('Blurred (gray)'); plt.axis('off')
plt.subplot(1, 4, 2); plt.imshow(D_x_vis, cmap='gray'); plt.title('D_x (horizontal)'); plt.axis('off')
plt.subplot(1, 4, 3); plt.imshow(D_y_vis, cmap='gray'); plt.title('D_y (vertical)'); plt.axis('off')
plt.subplot(1, 4, 4); plt.imshow(binary_image, cmap='gray'); plt.title('|∇I| > threshold'); plt.axis('off')
plt.show()



import cv2
import numpy as np
import math
import matplotlib.pyplot as plt

image_array = cv2.imread('cameraman.png')
if image_array.ndim == 3:
    gray = cv2.cvtColor(image_array, cv2.COLOR_BGR2GRAY)
else:
    gray = image_array
gray = gray.astype(np.float32)

def gaussian_kernel(size, sigma):
    kernel = np.zeros((size, size), dtype=np.float32)
    c = size // 2
    s2 = 2.0 * sigma * sigma
    for i in range(size):
        for j in range(size):
            x, y = i - c, j - c
            kernel[i, j] = math.exp(-(x*x + y*y) / s2)
    kernel /= kernel.sum()
    return kernel

def conv2d_full(a, b):
    ah, aw = a.shape
    bh, bw = b.shape
    out = np.zeros((ah + bh - 1, aw + bw - 1), dtype=np.float32)
    a_pad = np.pad(a, ((bh-1, bh-1), (bw-1, bw-1)), mode='constant')
    b_flip = np.flip(np.flip(b, 0), 1)
    for i in range(out.shape[0]):
        for j in range(out.shape[1]):
            region = a_pad[i:i+bh, j:j+bw]
            out[i, j] = np.sum(region * b_flip)
    return out

kernel_size = 5
sigma = 1.0
G = gaussian_kernel(kernel_size, sigma)

kx = np.array([[-1, 0, 1]], dtype=np.float32)
ky = np.array([[-1], [0], [1]], dtype=np.float32)

Kx = conv2d_full(G, kx)
Ky = conv2d_full(G, ky)

plt.figure(figsize=(10, 5))
plt.subplot(1, 2, 1)
plt.imshow(Kx, cmap='gray')
plt.title('Kx Kernel')
plt.axis('off')

plt.subplot(1, 2, 2)
plt.imshow(Ky, cmap='gray')
plt.title('Ky Kernel')
plt.axis('off')
plt.show()


D_x = cv2.filter2D(gray, ddepth=cv2.CV_32F, kernel=Kx, borderType=cv2.BORDER_REPLICATE)
D_y = cv2.filter2D(gray, ddepth=cv2.CV_32F, kernel=Ky, borderType=cv2.BORDER_REPLICATE)

magnitude = np.sqrt(D_x**2 + D_y**2)
threshold = 40.0
binary_image2 = (magnitude > threshold).astype(np.uint8) * 255

plt.figure(figsize=(6, 6))
plt.imshow(binary_image2, cmap='gray')
plt.title('Binary Edge Image (|∇I| > threshold)')
plt.axis('off')
plt.show()